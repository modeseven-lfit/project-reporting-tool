---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: "ðŸ“Š Production Reports"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug output'
        required: false
        type: boolean
        default: false
      skip_artifact_transfer:
        description: 'Skip JSON artifact transfer'
        required: false
        type: boolean
        default: true
  schedule:
    # Run every day at 7:00 AM UTC
    - cron: "0 7 * * *"

concurrency:
  group: production-reports
  cancel-in-progress: false  # Don't cancel production runs

permissions: {}

jobs:
  validate-secrets:
    name: "Validate Secrets"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    outputs:
      run_timestamp: ${{ steps.metadata.outputs.timestamp }}
      run_id: ${{ steps.metadata.outputs.run_id }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Generate run metadata"
        id: metadata
        shell: bash
        run: |
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "timestamp=$timestamp" >> "$GITHUB_OUTPUT"
          echo "run_id=${{ github.run_id }}" >> "$GITHUB_OUTPUT"

          {
            echo "## ðŸ“Š Production Report Generation"
            echo ""
            echo "**Started:** $timestamp"
            echo "**Run ID:** ${{ github.run_id }}"
            echo "**Trigger:** ${{ github.event_name }}"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Verify PROJECTS_JSON secret"
        shell: bash
        env:
          PROJECTS_JSON_B64: ${{ secrets.PROJECTS_JSON }}
        run: |
          # Check if secret is set and non-empty
          if [ -z "$PROJECTS_JSON_B64" ]; then
            echo "::error::PROJECTS_JSON secret is not set or not available"
            exit 1
          fi

          # Verify it's valid base64
          if ! echo "$PROJECTS_JSON_B64" | base64 -d > /dev/null 2>&1; then
            echo "::error::PROJECTS_JSON is not valid base64 encoded"
            exit 1
          fi

          echo "âœ… PROJECTS_JSON secret exists (base64 encoded)"

      - name: "Validate required secrets"
        shell: bash
        env:
          CLASSIC_READ_ONLY_PAT_TOKEN: >-
            ${{ secrets.CLASSIC_READ_ONLY_PAT_TOKEN }}
          GERRIT_REPORTS_PAT_TOKEN: >-
            ${{ secrets.GERRIT_REPORTS_PAT_TOKEN }}
          LF_GERRIT_INFO_MASTER_SSH_KEY: >-
            ${{ secrets.LF_GERRIT_INFO_MASTER_SSH_KEY }}
        # yamllint disable rule:line-length
        run: |
          validation_failed=false

          # SHA1 of empty string - used to detect empty secrets
          EMPTY_SHA1="da39a3ee5e6b4b0d3255bfef95601890afd80709"

          echo "ðŸ” Secrets Validation"
          echo ""

          # Function to compute SHA1 without trailing newline
          compute_sha1() {
            printf "%s" "$1" | sha1sum | awk '{print $1}'
          }

          # Check CLASSIC_READ_ONLY_PAT_TOKEN
          if [ -z "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "::error::CLASSIC_READ_ONLY_PAT_TOKEN secret is not set"
            echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN: MISSING"
            validation_failed=true
          else
            token_sha1=$(compute_sha1 "$CLASSIC_READ_ONLY_PAT_TOKEN")
            if [ "$token_sha1" = "$EMPTY_SHA1" ]; then
              echo "::error::CLASSIC_READ_ONLY_PAT_TOKEN is empty"
              echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN: EMPTY"
              validation_failed=true
            else
              echo "âœ… CLASSIC_READ_ONLY_PAT_TOKEN: $token_sha1"
            fi
          fi

          # Check GERRIT_REPORTS_PAT_TOKEN
          if [ -z "$GERRIT_REPORTS_PAT_TOKEN" ]; then
            echo "::error::GERRIT_REPORTS_PAT_TOKEN secret is not set"
            echo "âŒ GERRIT_REPORTS_PAT_TOKEN: MISSING"
            validation_failed=true
          else
            gerrit_token_sha1=$(compute_sha1 "$GERRIT_REPORTS_PAT_TOKEN")
            if [ "$gerrit_token_sha1" = "$EMPTY_SHA1" ]; then
              echo "::error::GERRIT_REPORTS_PAT_TOKEN is empty"
              echo "âŒ GERRIT_REPORTS_PAT_TOKEN: EMPTY"
              validation_failed=true
            else
              echo "âœ… GERRIT_REPORTS_PAT_TOKEN: $gerrit_token_sha1"
            fi
          fi

          # Check LF_GERRIT_INFO_MASTER_SSH_KEY (warning only)
          if [ -z "$LF_GERRIT_INFO_MASTER_SSH_KEY" ]; then
            echo "::warning::LF_GERRIT_INFO_MASTER_SSH_KEY secret not set"
            echo "âš ï¸  LF_GERRIT_INFO_MASTER_SSH_KEY: MISSING (HTTPS fallback)"
          else
            ssh_key_sha1=$(compute_sha1 "$LF_GERRIT_INFO_MASTER_SSH_KEY")
            if [ "$ssh_key_sha1" = "$EMPTY_SHA1" ]; then
              echo "::warning::LF_GERRIT_INFO_MASTER_SSH_KEY is empty"
              echo "âš ï¸  LF_GERRIT_INFO_MASTER_SSH_KEY: EMPTY (HTTPS fallback)"
            else
              echo "âœ… LF_GERRIT_INFO_MASTER_SSH_KEY: $ssh_key_sha1"
            fi
          fi

          # Write summary
          {
            echo "### ðŸ” Secrets Validation"
            echo ""
            if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ] && [ "${token_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **CLASSIC_READ_ONLY_PAT_TOKEN:** \`${token_sha1}\`"
            else
              echo "- âŒ **CLASSIC_READ_ONLY_PAT_TOKEN:** MISSING or EMPTY"
            fi

            if [ -n "$GERRIT_REPORTS_PAT_TOKEN" ] && [ "${gerrit_token_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **GERRIT_REPORTS_PAT_TOKEN:** \`${gerrit_token_sha1}\`"
            else
              echo "- âŒ **GERRIT_REPORTS_PAT_TOKEN:** MISSING or EMPTY"
            fi

            if [ -n "$LF_GERRIT_INFO_MASTER_SSH_KEY" ] && [ "${ssh_key_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **LF_GERRIT_INFO_MASTER_SSH_KEY:** \`${ssh_key_sha1}\`"
            else
              echo "- âš ï¸ **LF_GERRIT_INFO_MASTER_SSH_KEY:** MISSING or EMPTY (HTTPS fallback)"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$validation_failed" = true ]; then
            echo "::error::Secret validation failed"
            exit 1
          fi

          echo ""
          echo "âœ… All required secrets validated"
        # yamllint enable rule:line-length

      - name: "Validate PROJECTS_JSON schema"
        shell: bash
        env:
          PROJECTS_JSON_B64: ${{ secrets.PROJECTS_JSON }}
        # yamllint disable rule:line-length
        run: |
          # Decode base64-encoded PROJECTS_JSON secret
          projects_json=$(echo "$PROJECTS_JSON_B64" | base64 -d)

          # Validate JSON syntax
          if ! echo "$projects_json" | jq . > /dev/null 2>&1; then
            echo "::error::PROJECTS_JSON contains invalid JSON after base64 decode"
            exit 1
          fi

          # Validate structure
          if ! echo "$projects_json" | jq -e 'type == "array"' > /dev/null; then
            echo "::error::PROJECTS_JSON must be an array"
            exit 1
          fi

          # Validate required fields
          # Each project must have 'project' and 'slug',
          # plus either 'gerrit' or 'github'
          if ! echo "$projects_json" | \
            jq -e 'all(.project and .slug and (.gerrit or .github))' \
            > /dev/null; then
            echo "::error::Each project must have 'project' and" \
              "'slug' fields, plus at least one of 'gerrit' or 'github' fields"
            exit 1
          fi

          project_count=$(echo "$projects_json" | jq '. | length')
          echo "âœ… PROJECTS_JSON schema valid - $project_count project(s) defined"
        # yamllint enable rule:line-length

  build-matrix:
    name: "Build Matrix"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    outputs:
      matrix: ${{ steps.create-matrix.outputs.matrix }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Create matrix from ACTIVE_PROJECTS"
        id: create-matrix
        shell: bash
        run: |
          # Build matrix from ACTIVE_PROJECTS variable
          # This job does NOT access any secrets
          active_projects='${{ vars.ACTIVE_PROJECTS }}'

          if [ -z "$active_projects" ]; then
            echo "::error::ACTIVE_PROJECTS variable is not set"
            exit 1
          fi

          matrix=$(echo "{\"slug\": $active_projects}" | jq -c .)
          echo "matrix=$matrix" >> "$GITHUB_OUTPUT"

          project_count=$(echo "$active_projects" | jq '. | length')

          {
            echo "### Projects to Process"
            echo ""
            echo "**Total projects:** $project_count"
            echo ""
            echo "$active_projects" | jq -r '.[] | "- \(.)"'
          } >> "$GITHUB_STEP_SUMMARY"

  analyze:
    name: "${{ matrix.slug }}"
    needs: [validate-secrets, build-matrix]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.build-matrix.outputs.matrix) }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Extract project configuration"
        id: config
        shell: bash
        env:
          PROJECTS_JSON_B64: ${{ secrets.PROJECTS_JSON }}
          SLUG: ${{ matrix.slug }}
        run: |
          # Decode base64-encoded PROJECTS_JSON secret
          PROJECTS_JSON=$(echo "$PROJECTS_JSON_B64" | base64 -d)

          # Extract this project's configuration from PROJECTS_JSON
          # Validate that this slug exists
          if ! echo "$PROJECTS_JSON" | jq -e --arg slug "$SLUG" \
            '.[] | select(.slug == $slug)' > /dev/null; then
            echo "::error::Slug '$SLUG' not found in PROJECTS_JSON"
            echo "::error::Update ACTIVE_PROJECTS to match PROJECTS_JSON"
            exit 1
          fi

          project=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" '.[] | select(.slug == $slug) | .project')
          gerrit=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" '.[] | select(.slug == $slug) | .gerrit // ""')
          github=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" '.[] | select(.slug == $slug) | .github // ""')
          jenkins=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" '.[] | select(.slug == $slug) | .jenkins // ""')
          jenkins_user=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" \
            '.[] | select(.slug == $slug) | .jenkins_user // ""')
          jenkins_token=$(echo "$PROJECTS_JSON" | jq -r \
            --arg slug "$SLUG" \
            '.[] | select(.slug == $slug) | .jenkins_token // ""')

          # Set outputs (non-secret values only)
          echo "project=$project" >> "$GITHUB_OUTPUT"
          echo "gerrit=$gerrit" >> "$GITHUB_OUTPUT"
          echo "github=$github" >> "$GITHUB_OUTPUT"
          echo "jenkins=$jenkins" >> "$GITHUB_OUTPUT"

          # Set environment variables for secrets
          echo "JENKINS_USER=$jenkins_user" >> "$GITHUB_ENV"
          echo "JENKINS_API_TOKEN=$jenkins_token" >> "$GITHUB_ENV"

          echo "ðŸ“‹ Loaded configuration for: $project [$SLUG]"

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Clone Gerrit repositories"
        if: steps.config.outputs.gerrit != ''
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/gerrit-clone-action@61649739a768432a7ceac4203a00f61b9be51345  # v1.0.1
        id: clone-gerrit
        with:
          host: ${{ steps.config.outputs.gerrit }}
          output-path: "./${{ steps.config.outputs.gerrit }}"
          skip-archived: "true"
          threads: "4"
          clone-timeout: "600"
          retry-attempts: "5"
          retry-base-delay: "3.0"
          retry-max-delay: "60.0"
          use-https: "true"
          move-conflicting: "true"
          mirror: "false"

      - name: "Clone GitHub repositories"
        if: |
          steps.config.outputs.gerrit == '' &&
          steps.config.outputs.github != ''
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/gerrit-clone-action@61649739a768432a7ceac4203a00f61b9be51345  # v1.0.1
        id: clone-github
        env:
          GITHUB_TOKEN: ${{ secrets.CLASSIC_READ_ONLY_PAT_TOKEN }}
        with:
          host: "github.com/${{ steps.config.outputs.github }}"
          output-path: "./github.com/${{ steps.config.outputs.github }}"
          skip-archived: "true"
          threads: "8"
          clone-timeout: "600"
          retry-attempts: "5"
          retry-base-delay: "3.0"
          retry-max-delay: "60.0"
          use-https: "true"
          mirror: "false"

      - name: "Check clone status"
        shell: bash
        # yamllint disable rule:line-length
        run: |
          # Determine which clone step ran and check its outcome
          if [ -n "${{ steps.config.outputs.gerrit }}" ]; then
            # Gerrit project
            if [ "${{ steps.clone-gerrit.outcome }}" != "success" ]; then
              echo "::error::Failed to clone Gerrit repositories for ${{ steps.config.outputs.project }}"
              echo "::error::Gerrit server may be unavailable or decommissioned"
              exit 1
            else
              echo "âœ… Successfully cloned Gerrit repositories"
            fi
          elif [ -n "${{ steps.config.outputs.github }}" ]; then
            # GitHub-only project
            if [ "${{ steps.clone-github.outcome }}" != "success" ]; then
              echo "::error::Failed to clone GitHub repositories for ${{ steps.config.outputs.project }}"
              echo "::error::GitHub organization may be unavailable or inaccessible"
              exit 1
            else
              echo "âœ… Successfully cloned GitHub repositories"
            fi
          else
            echo "::error::Project has neither gerrit nor github configured"
            exit 1
          fi
        # yamllint enable rule:line-length

      - name: "Clone info-master repository"
        shell: bash
        run: |
          echo "ðŸ”— Cloning info-master repository via HTTPS"

          https_url="https://gerrit.linuxfoundation.org/infra/releng/info-master"

          git clone "$https_url" ./info-master
          echo "âœ… Cloned via HTTPS"

          echo "ðŸ“‚ Info-master contents:"
          find ./info-master -maxdepth 2 -type f -name "*.yaml" | head -5

      - name: "Install uv"
        # yamllint disable-line rule:line-length
        uses: astral-sh/setup-uv@eac588ad8def6316056a12d4907a9d4d84ff7a3b  # v7.3.0

      - name: "Set up Python"
        # yamllint disable-line rule:line-length
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405  # v6.2.0
        with:
          python-version: "3.11"

      - name: "Install dependencies"
        shell: bash
        run: uv sync --all-extras

      - name: "Generate reports for ${{ steps.config.outputs.project }}"
        shell: bash
        env:
          JENKINS_HOST: ${{ steps.config.outputs.jenkins }}
          # yamllint disable-line rule:line-length
          CLASSIC_READ_ONLY_PAT_TOKEN: ${{ secrets.CLASSIC_READ_ONLY_PAT_TOKEN }}
          GITHUB_ORG: ${{ steps.config.outputs.github }}
          SSH_AVAILABLE: ${{ env.SSH_AVAILABLE }}
        # yamllint disable rule:line-length
        run: |
          project="${{ steps.config.outputs.project }}"
          echo "ðŸ“Š Generating reports for $project"

          # Jenkins credentials already set in GITHUB_ENV by config step
          if [ -n "$JENKINS_USER" ] && [ -n "$JENKINS_API_TOKEN" ]; then
            echo "ðŸ” Using Jenkins authentication for $project"
            echo "âœ… Jenkins credentials configured (user: ${JENKINS_USER})"
          fi

          if [ -n "$JENKINS_HOST" ]; then
            echo "ðŸ”§ Jenkins: $JENKINS_HOST"
            if [ -n "$JENKINS_USER" ]; then
              echo "ðŸ”§ Jenkins User: $JENKINS_USER"
            else
              echo "â„¹ï¸ Jenkins authentication not configured"
            fi
          else
            echo "â„¹ï¸ Jenkins integration disabled"
          fi

          if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "ðŸ”§ GitHub API integration enabled"
            echo "ðŸ” Using token environment variable: CLASSIC_READ_ONLY_PAT_TOKEN"
            # Debug token format (show prefix only for security)
            token_prefix="${CLASSIC_READ_ONLY_PAT_TOKEN:0:10}"
            token_length="${#CLASSIC_READ_ONLY_PAT_TOKEN}"
            echo "ðŸ” Token prefix: ${token_prefix}..."
            echo "ðŸ” Token length: ${token_length} characters"
            # Check for whitespace
            if [[ "$CLASSIC_READ_ONLY_PAT_TOKEN" =~ [[:space:]] ]]; then
              echo "âš ï¸  WARNING: Token contains whitespace characters!"
              # Try to trim whitespace
              trimmed_token=""
              trimmed_token=$(echo "$CLASSIC_READ_ONLY_PAT_TOKEN" | tr -d '[:space:]')
              export CLASSIC_READ_ONLY_PAT_TOKEN="$trimmed_token"
              echo "ðŸ”§ Token trimmed, new length: ${#CLASSIC_READ_ONLY_PAT_TOKEN}"
            fi

            # Verify token is accessible in environment for Python
            echo "ðŸ” Environment variable CLASSIC_READ_ONLY_PAT_TOKEN is set"

            # Test GitHub API access directly
            echo "ðŸ” Testing GitHub API access..."
            response=""
            response=$(curl -s -H "Authorization: Bearer ${CLASSIC_READ_ONLY_PAT_TOKEN}" \
              "https://api.github.com/user" | jq -r '.login // .message // "ERROR"')
            echo "ðŸ” GitHub API test response: ${response}"
          else
            echo "âš ï¸ GitHub API integration disabled - CLASSIC_READ_ONLY_PAT_TOKEN not set"
          fi

          if [ -n "$GITHUB_ORG" ]; then
            echo "ðŸ” GITHUB_ORG environment variable: ${GITHUB_ORG}"
          else
            echo "ðŸ” GITHUB_ORG environment variable: NOT SET (will auto-derive)"
          fi

          echo "ðŸ“ Running command with --github-token-env CLASSIC_READ_ONLY_PAT_TOKEN"
          echo "ðŸ“ Verifying environment variable is set:"
          if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "âœ… CLASSIC_READ_ONLY_PAT_TOKEN is available to command"
          else
            echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN is NOT available to command"
          fi

          # Determine repos path based on project type
          if [ -n "${{ steps.config.outputs.gerrit }}" ]; then
            repos_path="./${{ steps.config.outputs.gerrit }}"
          elif [ -n "${{ steps.config.outputs.github }}" ]; then
            repos_path="./github.com/${{ steps.config.outputs.github }}"
          else
            echo "::error::Cannot determine repos path - no gerrit or github configured"
            exit 1
          fi

          echo "ðŸ“‚ Using repos path: ${repos_path}"

          uv run project-reporting-tool generate \
            --project "$project" \
            --repos-path "${repos_path}" \
            --output-dir "./reports" \
            --github-token-env CLASSIC_READ_ONLY_PAT_TOKEN \
            --verbose

          echo "âœ… Reports generated for $project"
        # yamllint enable rule:line-length

      - name: "Create report metadata"
        shell: bash
        run: |
          project="${{ steps.config.outputs.project }}"
          report_dir="./reports/$project"

          if [ ! -d "$report_dir" ]; then
            echo "::error::Report directory not found: $report_dir"
            exit 1
          fi

          # Create metadata file
          cat > "$report_dir/metadata.json" <<EOF
          {
            "project": "$project",
            "slug": "${{ matrix.slug }}",
            "gerrit_server": "${{ steps.config.outputs.gerrit }}",
            "jenkins_server": "${{ steps.config.outputs.jenkins }}",
            "github_org": "${{ steps.config.outputs.github }}",
            "generated_at": \
              "${{ needs.validate-secrets.outputs.run_timestamp }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}",
            "workflow_run_attempt": "${{ github.run_attempt }}",
            "git_sha": "${{ github.sha }}",
            "git_ref": "${{ github.ref }}",
            "environment": "production"
          }
          EOF

          echo "âœ… Metadata created"

      - name: "Copy raw data files to temp directory"
        shell: bash
        run: |
          # Create temp directory for raw data files
          mkdir -p ./temp-raw-data-${{ matrix.slug }}

          # Copy JSON files to temp directory (flattening the structure)
          project="${{ steps.config.outputs.project }}"
          if [ -f "./reports/$project/report_raw.json" ]; then
            cp "./reports/$project/report_raw.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi
          if [ -f "./reports/$project/config_resolved.json" ]; then
            cp "./reports/$project/config_resolved.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi
          if [ -f "./reports/$project/metadata.json" ]; then
            cp "./reports/$project/metadata.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi

          echo "Raw data files prepared for upload"

      - name: "Upload raw data artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: raw-data-${{ matrix.slug }}
          path: ./temp-raw-data-${{ matrix.slug }}/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 9

      - name: "Upload report artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: reports-${{ matrix.slug }}
          path: ./reports/${{ steps.config.outputs.project }}/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 6

      - name: "Upload clone manifest"
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: clone-manifest-${{ matrix.slug }}
          # yamllint disable-line rule:line-length
          path: "./${{ steps.config.outputs.gerrit != '' && steps.config.outputs.gerrit || format('github.com/{0}', steps.config.outputs.github) }}/clone-manifest.json"
          retention-days: 90
          if-no-files-found: warn

      - name: "Determine log file path"
        id: log-path
        shell: bash
        run: |
          # Log file location based on gerrit-clone-action v0.1.14 behavior:
          # - Gerrit: ./gerrit.example.org/gerrit.example.org.log
          # - GitHub: ./github.com/orgname/github.com.orgname.log
          if [ -n "${{ steps.config.outputs.gerrit }}" ]; then
            # Gerrit: ./gerrit.example.org/gerrit.example.org.log
            gerrit_host="${{ steps.config.outputs.gerrit }}"
            log_path="./${gerrit_host}/${gerrit_host}.log"
          else
            # GitHub: ./github.com/orgname/github.com.orgname.log
            github_org="${{ steps.config.outputs.github }}"
            sanitized_host="github.com.${github_org}"
            log_path="./github.com/${github_org}/${sanitized_host}.log"
          fi
          echo "path=$log_path" >> "$GITHUB_OUTPUT"
          echo "Log file path: $log_path"

      - name: "Upload clone log"
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: clone-log-${{ matrix.slug }}
          path: ${{ steps.log-path.outputs.path }}
          retention-days: 90
          if-no-files-found: warn

  publish:
    name: "Publish GitHub Pages"
    needs: [validate-secrets, build-matrix, analyze]
    # Run if validation succeeded and analyze completed (even with failures)
    # This allows publishing reports from successful matrix jobs
    # yamllint disable-line rule:line-length
    if: always() && needs.validate-secrets.result == 'success' && (needs.analyze.result == 'success' || needs.analyze.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    timeout-minutes: 20
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Checkout main branch for scripts"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Copy script from main branch"
        shell: bash
        run: |
          mkdir -p /tmp/main-scripts
          cp .github/scripts/generate-index.sh /tmp/main-scripts/
          chmod +x /tmp/main-scripts/generate-index.sh
          echo "âœ… Copied generate-index.sh from main branch"

      - name: "Checkout gh-pages branch"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Download all report artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          pattern: reports-*
          path: ./downloaded-reports
        continue-on-error: true

      - name: "Check for available reports"
        id: check-reports
        shell: bash
        run: |
          if [ -d "./downloaded-reports" ]; then
            report_count=$(find ./downloaded-reports -mindepth 1 \
              -maxdepth 1 -type d | wc -l)
            echo "count=$report_count" >> "$GITHUB_OUTPUT"
            echo "ðŸ“¦ Found $report_count report artifact(s)"
            if [ "$report_count" -eq 0 ]; then
              echo "::warning::No report artifacts found to publish"
            fi
          else
            echo "count=0" >> "$GITHUB_OUTPUT"
            echo "::warning::No downloaded-reports directory found"
          fi

      - name: "Prepare production reports at root"
        if: steps.check-reports.outputs.count != '0'
        shell: bash
        # yamllint disable rule:line-length
        run: |
          echo "ðŸ“¦ Preparing production reports at root level"

          # Process each downloaded report
          report_count=0
          for artifact_dir in ./downloaded-reports/reports-*
          do
            if [ ! -d "$artifact_dir" ]; then
              continue
            fi

            # Extract slug from artifact directory name (reports-{slug})
            slug=$(basename "$artifact_dir" | sed 's/^reports-//')

            echo "Processing artifact: reports-$slug"

            # Create project directory at root level
            target_dir="$slug"
            mkdir -p "$target_dir"

            # Find and copy report files (handle nested directory structure)
            # Artifacts may contain project directory, so search recursively
            report_html=$(find "$artifact_dir" -name "report.html" -type f | head -n 1)
            if [ -n "$report_html" ]; then
              cp "$report_html" "$target_dir/"
            fi

            report_json=$(find "$artifact_dir" -name "report_raw.json" -type f | head -n 1)
            if [ -n "$report_json" ]; then
              cp "$report_json" "$target_dir/"
            fi

            report_md=$(find "$artifact_dir" -name "report.md" -type f | head -n 1)
            if [ -n "$report_md" ]; then
              cp "$report_md" "$target_dir/"
            fi

            metadata=$(find "$artifact_dir" -name "metadata.json" -type f | head -n 1)
            if [ -n "$metadata" ]; then
              cp "$metadata" "$target_dir/"
            fi

            theme_css=$(find "$artifact_dir" -name "theme.css" -type f | head -n 1)
            if [ -n "$theme_css" ]; then
              cp "$theme_css" "$target_dir/"
            fi

            report_count=$((report_count + 1))
            echo "  âœ… Prepared $slug"
          done

          echo "REPORT_COUNT=$report_count" >> "$GITHUB_ENV"
          echo "âœ… Prepared $report_count project report(s) at root"
        # yamllint enable rule:line-length

      - name: "Generate index page"
        if: steps.check-reports.outputs.count != '0'
        shell: bash
        run: |
          # Create .nojekyll to disable Jekyll processing
          touch .nojekyll
          echo "âœ… Created .nojekyll file"

          # Generate index at root (pass "." as directory)
          bash /tmp/main-scripts/generate-index.sh . production

      - name: "Commit and push changes"
        if: steps.check-reports.outputs.count != '0'
        shell: bash
        run: |
          git config user.name "lf-releng-reports-bot"
          git config user.email "lf-releng+reports-bot@linuxfoundation.org"

          # Add all project directories and index
          git add index.html || true
          git add .nojekyll || true

          # Add all project report directories (exclude previews/)
          for project_dir in */; do
            # Skip previews and non-report directories
            if [ -d "$project_dir" ] && \
               [ "$project_dir" != "previews/" ] && \
               [ -f "$project_dir/report.html" ]; then
              echo "Adding $project_dir"
              git add "$project_dir"
            fi
          done

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          cat > /tmp/commit-msg.txt <<EOF
          chore: update production reports (run ${{ github.run_id }})

          Generated: ${{ needs.validate-secrets.outputs.run_timestamp }}
          Reports: ${{ env.REPORT_COUNT }} project(s)
          Run: ${{ github.run_id }}
          EOF

          git commit -F /tmp/commit-msg.txt
          git push origin gh-pages

          echo "âœ… Published to GitHub Pages"

          {
            echo "## ðŸ“¤ Reports Published"
            echo ""
            echo "**Reports published:** ${{ env.REPORT_COUNT }}"
            echo "**Branch:** gh-pages"
            echo "**Path:** (root)"
            echo ""
            echo "### ðŸŒ View Reports"
            echo ""
            echo "Reports will be available at:"
            owner="${{ github.repository_owner }}"
            repo="${{ github.event.repository.name }}"
            echo "https://${owner}.github.io/${repo}/"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Report publish status"
        if: steps.check-reports.outputs.count == '0'
        shell: bash
        run: |
          {
            echo "## âš ï¸ No Reports Published"
            echo ""
            echo "No report artifacts were available to publish."
            echo "This may occur if all matrix jobs failed."
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Fail job if no reports were published"
        if: steps.check-reports.outputs.count == '0'
        shell: bash
        run: |
          echo "::error::No report artifacts were available to publish"
          exit 1

  copy-to-gerrit-reports:
    name: "Transfer/Copy Artifacts"
    needs: [validate-secrets, build-matrix, analyze]
    # Run if validation succeeded and analyze completed (even with failures)
    # yamllint disable-line rule:line-length
    if: always() && needs.validate-secrets.result == 'success' && (needs.analyze.result == 'success' || needs.analyze.result == 'failure') && (github.event_name != 'workflow_dispatch' || inputs.skip_artifact_transfer == false)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 15
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Checkout repository for scripts"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Download all artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          path: ./downloaded-artifacts
          merge-multiple: false
        continue-on-error: true

      - name: "Check for available artifacts"
        id: check-artifacts
        shell: bash
        run: |
          if [ -d "./downloaded-artifacts" ]; then
            artifact_count=$(find ./downloaded-artifacts -mindepth 1 \
              -maxdepth 1 -type d | wc -l)
            echo "count=$artifact_count" >> "$GITHUB_OUTPUT"
            echo "ðŸ“¦ Found $artifact_count artifact(s)"
            if [ "$artifact_count" -eq 0 ]; then
              echo "::warning::No artifacts found to transfer"
            fi
          else
            echo "count=0" >> "$GITHUB_OUTPUT"
            echo "::warning::No downloaded-artifacts directory found"
          fi

      - name: "Generate date folder name"
        id: date
        shell: bash
        run: |
          DATE_FOLDER=$(date -u +%Y-%m-%d)
          echo "folder=${DATE_FOLDER}" >> "$GITHUB_OUTPUT"
          echo "Date folder: ${DATE_FOLDER}"

      - name: "Debug: Show downloaded artifacts"
        if: steps.check-artifacts.outputs.count != '0'
        shell: bash
        run: |
          echo "=== Downloaded artifacts structure ==="
          if [ -d "./downloaded-artifacts" ]; then
            find ./downloaded-artifacts -maxdepth 2 -type d | sort
            echo ""
            echo "=== Total artifact count ==="
            find ./downloaded-artifacts -mindepth 1 -maxdepth 1 -type d | wc -l
            echo ""
            echo "=== Total file count ==="
            find ./downloaded-artifacts -type f | wc -l
          else
            echo "ERROR: ./downloaded-artifacts directory does not exist!"
            exit 1
          fi

      - name: "Copy artifacts to gerrit-reports repository"
        if: steps.check-artifacts.outputs.count != '0'
        shell: bash
        env:
          GERRIT_REPORTS_PAT_TOKEN: ${{ secrets.GERRIT_REPORTS_PAT_TOKEN }}
        run: |
          chmod +x .github/scripts/copy-artifacts-simple.sh
          .github/scripts/copy-artifacts-simple.sh \
            "${{ steps.date.outputs.folder }}" \
            "${{ github.run_id }}" \
            "./downloaded-artifacts" \
            "$GERRIT_REPORTS_PAT_TOKEN"

      - name: "Generate job summary"
        if: always()
        shell: bash
        # yamllint disable rule:line-length
        run: |
          artifact_count="${{ steps.check-artifacts.outputs.count }}"

          # Determine actual status based on artifact count
          if [ "$artifact_count" -eq 0 ] 2>/dev/null || [ -z "$artifact_count" ]; then
            status="failure"
            status_emoji="âŒ"
          else
            status="success"
            status_emoji="âœ…"
          fi

          {
            echo "## ðŸ“¦ Artifacts Transferred"
            echo ""
            echo "**Date Folder:** ${{ steps.date.outputs.folder }}"
            echo "**Workflow Run:** ${{ github.run_id }}"
            echo "**Target Repository:** modeseven-lfit/gerrit-reports"
            echo "**Status:** ${status_emoji} ${status}"
            echo "**Artifacts Found:** ${artifact_count:-0}"
            echo ""

            # Only show repository link if artifacts were actually transferred
            if [ "$artifact_count" -gt 0 ] 2>/dev/null; then
              echo "### ðŸ”— View in Repository"
              echo ""
              echo "https://github.com/modeseven-lfit/gerrit-reports/tree/main/data/artifacts/${{ steps.date.outputs.folder }}"
              echo ""
            else
              echo "### âš ï¸ No Artifacts Transferred"
              echo ""
              echo "No artifacts were available to transfer to the target repository."
              echo "This occurs when all matrix analysis jobs fail."
              echo ""
              echo "**Troubleshooting:**"
              echo "- Check the **Analyze** job logs for errors"
              echo "- Verify the PROJECTS_JSON secret is properly base64-encoded"
              echo "- Ensure Gerrit/GitHub servers are accessible"
              echo ""
            fi
          } >> "$GITHUB_STEP_SUMMARY"
        # yamllint enable rule:line-length

      - name: "Fail job if no artifacts were transferred"
        if: steps.check-artifacts.outputs.count == '0'
        shell: bash
        run: |
          echo "::error::No artifacts were available to transfer"
          exit 1

  summary:
    name: "Workflow Summary"
    needs:
      - validate-secrets
      - build-matrix
      - analyze
      - publish
      - copy-to-gerrit-reports
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e  # v2.14.2
        with:
          egress-policy: "audit"

      - name: "Generate workflow summary"
        shell: bash
        env:
          PROJECTS_JSON_B64: ${{ secrets.PROJECTS_JSON }}
        run: |
          # Helper function to convert result to emoji
          result_emoji() {
            case "$1" in
              success) echo "âœ…" ;;
              failure) echo "âŒ" ;;
              cancelled) echo "âš ï¸" ;;
              skipped) echo "â­ï¸" ;;
              *) echo "â“" ;;
            esac
          }

          # Parse projects JSON to get slugs (decode from base64)
          projects_json=$(echo "$PROJECTS_JSON_B64" | base64 -d)

          {
            echo "## ðŸ“Š Production Report Generation Complete"
            echo ""
            echo "**Completed:** $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "**Status:** ${{ needs.publish.result }}"
            echo ""
            echo "### Job Results"
            echo ""
            echo "- **Validate Secrets:** $(result_emoji \
              '${{ needs.validate-secrets.result }}')"
            echo "- **Analyze:** $(result_emoji \
              '${{ needs.analyze.result }}')"
            echo "- **Publish:** $(result_emoji \
              '${{ needs.publish.result }}')"
            echo "- **Copy:** $(result_emoji \
              '${{ needs.copy-to-gerrit-reports.result }}')"
            echo ""

            # Note about failures - partial vs complete failure
            if [ "${{ needs.analyze.result }}" = "failure" ]; then
              # Check if publish also failed (indicates complete failure)
              if [ "${{ needs.publish.result }}" = "failure" ] && \
                 [ "${{ needs.copy-to-gerrit-reports.result }}" = "failure" ]
              then
                echo "### âŒ Complete Matrix Failure"
                echo ""
                echo "All project analysis jobs failed." \
                  "No reports were generated."
                echo ""
                echo "**Troubleshooting:**"
                echo "- Check the **Analyze** job logs for specific errors"
                echo "- Verify the PROJECTS_JSON secret is properly" \
                  "base64-encoded"
                echo "- Ensure Gerrit/GitHub servers are accessible"
                echo "- Check for network connectivity issues"
                echo ""
              else
                echo "### âš ï¸ Partial Matrix Failure"
                echo ""
                echo "Some project analysis jobs failed, but reports from"
                echo "successful jobs were still published."
                echo ""
              fi
            fi

            # Add links to project reports if publish succeeded
            if [ "${{ needs.publish.result }}" = "success" ]; then
              echo "### ðŸ“‘ Project Reports"
              echo ""
              owner="${{ github.repository_owner }}"
              repo="${{ github.event.repository.name }}"
              base_url="https://${owner}.github.io/${repo}"

              # Parse and display each project with link
              echo "$projects_json" | \
                jq -r '.[] | "\(.project)|\(.slug)"' | \
                while IFS='|' read -r project_name slug; do
                report_url="${base_url}/${slug}/report.html"
                data_url="${base_url}/${slug}/report_raw.json"
                echo "- **${project_name}:** [View Report](${report_url})" \
                  "â€¢ [Raw Data](${data_url})"
              done
              echo ""
              echo "**Index:** [View All Reports](${base_url}/)"
              echo ""
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Prepare email notification"
        if: always() && vars.SEND_EMAIL_NOTIFICATIONS == 'true'
        shell: bash
        env:
          PROJECTS_JSON_B64: ${{ secrets.PROJECTS_JSON }}
        run: |
          # Print mail configuration for debugging
          echo "=== Email Configuration ==="
          echo "SMTP_SERVER: ${{ vars.SMTP_SERVER }}"
          echo "SMTP_USERNAME: ${{ vars.SMTP_USERNAME }}"
          echo "REPORT_EMAIL_ADDRESS: ${{ vars.REPORT_EMAIL_ADDRESS }}"
          echo "FROM: no-reply@linuxfoundation.org"
          echo "==========================="
          echo ""

          # Helper function to convert result to emoji
          result_emoji() {
            case "$1" in
              success) echo "âœ…" ;;
              failure) echo "âŒ" ;;
              cancelled) echo "âš ï¸" ;;
              skipped) echo "â­ï¸" ;;
              *) echo "â“" ;;
            esac
          }

          # Parse projects JSON to get slugs (decode from base64)
          projects_json=$(echo "$PROJECTS_JSON_B64" | base64 -d)
          owner="${{ github.repository_owner }}"
          repo="${{ github.event.repository.name }}"
          base_url="https://${owner}.github.io/${repo}"

          # Build email body
          cat > /tmp/email_body.txt << 'EMAIL_EOF'
          ðŸ“Š Production Report Generation Complete

          EMAIL_EOF

          date_completed=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          validate_result="${{ needs.validate-secrets.result }}"
          analyze_result="${{ needs.analyze.result }}"
          publish_result="${{ needs.publish.result }}"
          copy_result="${{ needs.copy-to-gerrit-reports.result }}"

          {
            echo "Completed: ${date_completed}"
            echo "Status: ${publish_result}"
            echo ""
            echo "Job Results:"
            validate_emoji=$(result_emoji "${validate_result}")
            echo "- Validate: ${validate_emoji} ${validate_result}"
            analyze_emoji=$(result_emoji "${analyze_result}")
            echo "- Analyze: ${analyze_emoji} ${analyze_result}"
            publish_emoji=$(result_emoji "${publish_result}")
            echo "- Publish: ${publish_emoji} ${publish_result}"
            copy_emoji=$(result_emoji "${copy_result}")
            echo "- Copy: ${copy_emoji} ${copy_result}"
            echo ""
          } >> /tmp/email_body.txt

          # Add note about partial failures
          if [ "${analyze_result}" = "failure" ]; then
            {
              echo "âš ï¸ Partial Matrix Failure"
              echo "Some project analysis jobs failed, but reports from"
              echo "successful jobs were still published."
              echo ""
            } >> /tmp/email_body.txt
          fi

          # Add project reports if publish succeeded
          if [ "${publish_result}" = "success" ]; then
            {
              echo "ðŸ“‘ Project Reports:"
              echo ""
            } >> /tmp/email_body.txt

            echo "$projects_json" | \
              jq -r '.[] | "\(.project)|\(.slug)"' | \
              while IFS='|' read -r project_name slug; do
                report_url="${base_url}/${slug}/report.html"
                data_url="${base_url}/${slug}/report_raw.json"
                echo "- ${project_name}: ${report_url}" \
                  >> /tmp/email_body.txt
                echo "  Raw Data: ${data_url}" >> /tmp/email_body.txt
              done

            {
              echo ""
              echo "Index: ${base_url}/"
              echo ""
            } >> /tmp/email_body.txt
          fi

          run_id="${{ github.run_id }}"
          repo="${{ github.repository }}"
          server="${{ github.server_url }}"
          workflow_url="${server}/${repo}/actions/runs/${run_id}"
          echo "View full workflow run: ${workflow_url}" >> /tmp/email_body.txt

      - name: "Send email with dawidd6/action-send-mail"
        if: always() && vars.SEND_EMAIL_NOTIFICATIONS == 'true'
        # yamllint disable-line rule:line-length
        uses: dawidd6/action-send-mail@62a2d05b79935ad4fb90ce9079928099579c14ac  # v9
        with:
          server_address: ${{ vars.SMTP_SERVER }}
          server_port: 587
          username: ${{ vars.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: >-
            Production Report Generation Complete -
            ${{ github.repository }}
          to: ${{ vars.REPORT_EMAIL_ADDRESS }}
          from: no-reply@linuxfoundation.org
          body: file:///tmp/email_body.txt
